
'''
 4.4.1. NormStartSender()
4.4.2. NormStopSender()

4.4.3. NormSetTxRate()
4.4.4. NormGetTxRate()
4.4.5. NormSetTxSocketBuffer()
4.4.6. NormSetFlowControl()
4.4.7. NormSetCongestionControl()

4.4.8. NormSetTxRateBounds()
4.4.9. NormSetTxCacheBounds()
4.4.10. NormSetAutoParity()
4.4.11. NormGetGrttEstimate()
4.4.12. NormSetGrttEstimate()
4.4.13. NormSetGrttMax()
4.4.14. NormSetGrttProbingMode()
4.4.15. NormSetGrttProbingInterval()
4.4.16. NormSetBackoffFactor()
4.4.17. NormSetGroupSize()
4.4.18. NormSetTxRobustFactor()

4.4.19. NormFileEnqueue()
4.4.20. NormDataEnqueue()
4.4.21. NormRequeueObject()

4.4.30. NormSetWatermark()
4.4.31. NormCancelWatermark()
4.4.32. NormAddAckingNode()
4.4.33. NormRemoveAckingNode()
4.4.34. NormGetNextAckingNode()
4.4.35. NormGetAckingStatus()

4.4.36. NormSendCommand()
4.4.37. NormCancelCommand()


4.4.22. NormStreamOpen()
4.4.23. NormStreamClose()
4.4.24. NormStreamWrite()
4.4.25. NormStreamFlush()
4.4.26. NormStreamSetAutoFlush()
4.4.27. NormStreamSetPushEnable()
4.4.28. NormStreamHasVacancy()
4.4.29. NormStreamMarkEom()


'''

from fastapi import APIRouter
router = APIRouter()
from fastapi import Depends, HTTPException
from starlette.status import HTTP_400_BAD_REQUEST
import pynorm
import deps


    
from pydantic import BaseModel,validator,Field
import pydantic
from ipaddress import IPv4Address
 
from .scheme import LinkBase,Reply       
class LinkCreate(LinkBase):
    '''
    
    '''
    ccEnable:bool = Field(default=True)
    rateMix:float|None = Field( description='''  启用拥塞控制时(ccEnable=True)，最小信息速率，单位Kbps； 未启用拥塞控制时，该值无效 ''')
    rateMax:float|None = Field( description='''  启用拥塞控制时(ccEnable=True)，最大信息速率，单位Kbps； 未启用拥塞控制时，该值无效''')
    txRate:float|None = Field ( description='''  不启用拥塞控制时(ccEnable=False)，按固定速率发送，单位Kbps''')    
    segmentSize:int|None =Field(default=1400, description=''' the maximum payload size (in bytes) of NORM sender messages (not including any NORM message header fields) ''')
    blockSize:int|None = Field(default=128, description=''' the number of source symbol segments (packets) per coding block ''')
    numParity:int|None = Field(default=0, description='''the maximum number of parity symbol segments (packets) the sender is willing to calculate per FEC coding block ''') 
    
    
class LinkUpdate(BaseModel):
    '''
    
    '''
    destAddr:str|None #= Field 
    destPort:int|None #= Field()
    bufferSpace:int = Field( description='''This specifies the maximum memory space (in bytes) the NORM protocol engine
        is allowed to use to buffer any sender calculated FEC segments and repair state for the session.
        The optimum bufferSpace value is function of the network topology bandwidth*delay product and packet loss characteristics.
        If the bufferSpace limit is too small, the protocol may operate less efficiently as the sender is required to possibly recalculate 
        FEC parity segments and/or provide less efficient repair transmission strategies (resort to explicit repair) 
        when state is dropped due to constrained buffering resources. However, 
        note the protocol will still provide reliable transfer. A large bufferSpace allocation is
        safer at the expense of possibly committing more memory resources.''' )
    
    segmentSize:int|None = Field( description= '''This parameter sets the maximum payload size (in bytes) of NORM sender messages (not including any NORM message header fields). 
    A sender's segmentSize value is also used by receivers to limit the payload content of some feedback messages (e.g. NORM_NACK message content, etc.) generated in response to that sender. 
    Note different senders within a NormSession may use different segmentSize values. 
    Generally, the appropriate segment size to use is dependent upon the types of networks forming the multicast topology, but applications may choose different values for other purposes. 
    Note that application designers MUST account for the size of NORM message headers when selecting a segmentSize. 
    For example, the NORM_DATA message header for a NORM_OBJECT_STREAM with full header extensions is 48 bytes in length.
    In this case, the UDP payload size of these messages generated by NORM would be up to (48 + segmentSize) bytes.'''
    )
    blockSize:int|None = Field( description= ''' This parameter sets the number of source symbol segments (packets) per coding block, for the systematic Reed-Solomon FEC code used in the current NORM implementation. For traditional systematic block code "(n,k)" nomenclature, the blockSize value corresponds to "k". NORM logically segments transport object data content into coding blocks and the blockSize parameter determines the number of source symbol segments (packets) comprising a single coding block where each source symbol segment is up to segmentSize bytes in length.. A given block's parity symbol segments are calculated using the corresponding set of source symbol segments. The maximum blockSize allowed by the 8-bit Reed-Solomon codes in NORM is 255, with the further limitation that (blockSize + numParity) <= 255.
    ''')
    
    numParity:int|None = Field( description= '''This parameter sets the maximum number of parity symbol segments (packets) the sender is willing to calculate per FEC coding block. The parity symbol segments for a block are calculated from the corresponding blockSize source symbol segments. In the "(n,k)" nomenclature mention above, the numParity value corresponds to "n - k". A property of the Reed-Solomon FEC codes used in the current NORM implementation is that one parity segment can fill any one erasure (missing segment (packet)) for a coding block. For a given blockSize, the maximum numParity value is (255 - blockSize). However, note that computational complexity increases significantly with increasing numParity values and applications may wish to be conservative with respect to numParity selection, given anticipated network packet loss conditions and group size scalability concerns. Additional FEC code options may be provided for this NORM implementation in the future with different parameters, capabilities, trade-offs, and computational requirements.    
    ''')


import os
import asyncio
from util.netifaces_ext import get_interface_by_ip

from .norm_common import get_session

@router.post("/link", )
async def create_sender_session(
    linkID:int, 
    create:LinkCreate, 
    instance:pynorm.Instance = Depends(deps.get_instance),
):
    '''
       创建一个发送Session
    '''
    if linkID in instance._sessionIndex2Session:
        raise HTTPException(HTTP_400_BAD_REQUEST, detail=f"linkID { linkID} already exists!")
    
    localAddr = create.localAddr
    loop = asyncio.get_running_loop()
    iface:str|None  = await loop.run_in_executor(None, get_interface_by_ip, localAddr)
    if not iface:
        raise HTTPException(HTTP_400_BAD_REQUEST, detail=f"{localAddr} is not valid local Addr")     
    
    # Win10 only check,but not use it.
    if os.name =="nt":
        iface = None
    
    session = deps.create_sender_session(instance=instance, ** create.dict (exclude_unset=True),
                                         iface=iface, 
                                         sessionIndex = linkID
                                         )
    return {"sessionHandle": session._session}

@router.delete("/link", )
async def remove_link( linkID:int,
                       instance:pynorm.Instance = Depends(deps.get_instance),
                       ):
    '''
        删除发送Session
    '''
    if session:=instance.destroySessionByIndex(linkID):
        return {"sessionHandle": session._session}
    else:
        raise HTTPException(HTTP_400_BAD_REQUEST, detail=f"linkID {linkID} not exists!")
    
    

@router.get("/status")
async def instance_status(
    linkID:int,
    instance:pynorm.Instance = Depends(deps.get_instance),
    ):
    if session:=instance._sessionIndex2Session.get(linkID):
        session:pynorm.session.Session
        return {'txRate': session.getTxRate()}
    else:
        raise HTTPException(HTTP_400_BAD_REQUEST, detail=f"linkID {linkID} not exists!") 
    
    
from .scheme import AddObjectRsp,FailureReply    
@router.get("/add_server_file", response_model= AddObjectRsp|FailureReply)
async def send_a_file_located_in_server( linkID:int,
                      filePath:str,
                      watermark:bool=False,
                      instance:pynorm.Instance = Depends(deps.get_instance),
                       ):
    '''
        添加一个Web后台服务器上已经存在的文件，进行组播文件发送;
        event TX_WATERMARK_COMPLETED is posted for the given session when the flushing process or positive acknowledgment collection has completed.
        
    '''
    if session:=instance._sessionIndex2Session.get(linkID):
        session:pynorm.session.Session
        obj:pynorm.object.Object = session.fileEnqueue( os.path.expanduser(filePath) , filePath.encode())
        if obj.handle == pynorm.NORM_OBJECT_INVALID:
            return {"success":False,"error": "OBJECT_INVALID"}
        if watermark:
            session.setWatermark(obj)
        session.id2obj[obj._object] = obj
        return {"success":True ,"handle":obj._object }
    else:
        raise HTTPException(HTTP_400_BAD_REQUEST, detail=f"linkID {linkID} not exists!")


@router.put("/ttl")
async def set_TTL( 
            linkID:int,
            ttl:int , #success:bool= Field(default=False)
            instance:pynorm.Instance = Depends(deps.get_instance),
                       ):
    '''
       8bit,IP header的TTL字段
       specifies the time-to-live (ttl) for IP Multicast datagrams
    '''
    session:pynorm.session.Session = get_session(instance, linkID)
    success = session.setTTL(ttl)
    return { "success":success }


@router.put("/tos")
async def set_TOS( 
            linkID:int,
            tos:int,
            instance:pynorm.Instance = Depends(deps.get_instance),
                       ):
    '''
        8bit,IP header的TOS字段 
        specifies the type-of-service (tos) field value used in IP Multicast datagrams 
    '''
    session:pynorm.session.Session = get_session(instance, linkID)
    success = session.setTOS(tos)
    return { "success":success }

@router.post("/cmd")
async def send_command( 
            linkID:int,
            cmd:str,
            instance:pynorm.Instance = Depends(deps.get_instance),
                       ):
    '''
        发送命令
        收方： RX_CMD_NEW  发方：TX_CMD_SENT
        要求： cmd.encode('utf-8') <=Session的segmentLength 
        bool NormSendCommand(NormSessionHandle session,
                         const char*       cmdBuffer,
                         unsigned int      cmdLength,
                         bool              robust = false); 
    '''
    session:pynorm.session.Session = get_session(instance, linkID)
    success = session.sendCommand(cmd.encode() )
    return { "success":success }


@router.put("/txRobustFactor")
async def set_Tx_Robust_Factor( 
            linkID:int,
            robustFactor:int, 
            instance:pynorm.Instance = Depends(deps.get_instance),
                       ):
    '''
void NormSetTxRobustFactor(NormSessionHandle sessionHandle,
                           int               txRobustFactor); 
    '''
    session:pynorm.session.Session = get_session(instance, linkID)
    success = session.setTxRobustFactor(robustFactor)
    return { "success":success }


    

@router.put("/txRateBounds", response_model=Reply)
async def set_TxRateBounds(
    linkID:int, 
    rateMin:float=-1,
    rateMax:float=-1,
    instance:pynorm.Instance = Depends(deps.get_instance),
):
    '''
      启用拥塞控制时，设定最小、最大速率， 单位Kbps
      One or both of these parameters may be set to values less than zero to remove one or both bounds
      
      
      bool NormSetTxRateBounds(NormSessionHandle sessionHandle,
                               double            rateMin,
                               double            rateMax);
    
    '''
    session = get_session(instance, linkID)
    success = session.setTxRateBounds(rateMin=rateMin*1000, rateMax=rateMax*1000)
    return {"success": success } 


@router.put("/txRate", response_model=Reply)
async def set_TxRate(
    linkID:int, 
    txRate:float,
    instance:pynorm.Instance = Depends(deps.get_instance),
):
    '''
      
      设定固定的发送速率，单位Kbps；仅在关闭拥塞控制时生效，
      可以在运行时动态调整速率
    
    '''
    session:pynorm.session.Session = get_session(instance, linkID)
    session.setTxRate(txRate=txRate*1000)
    
 
@router.put("/txCacheBounds", response_model=Reply)
async def set_Tx_Cache_Bounds(
    linkID:int, 
    sizeMax:int,
    countMin:int,
    countMax:int,
    instance:pynorm.Instance = Depends(deps.get_instance),
):
    '''
      the number and total size of pending transmit objects a NORM sender will allow to be enqueued by the application 
    void NormSetTxCacheBounds(NormSessionHandle sessionHandle,
                                    NormSize          sizeMax,
                                    unsigned int      countMin,
                                    unsigned int      countMax);
    
    '''
    session:pynorm.session.Session = get_session(instance, linkID)
    session.setTxCacheBounds(sizeMax, countMin, countMax)
    #session.setTxRate(txRate=txRate*1000)

    
    
@router.put("/congestionControl", response_model=Reply)
async def set_congestion_control(
    linkID:int, 
    ccEnable:bool,
    adjustRate:bool=True,
    instance:pynorm.Instance = Depends(deps.get_instance),
):
    '''
     开启或者关闭拥塞控制 
     void NormSetCongestionControl(NormSessionHandle sessionHandle, bool enable, bool adjustRate)
    '''
    session:pynorm.session.Session = get_session(instance, linkID)
    session.setCongestionControl(ccEnable) 

@router.put("/autoParity", )
async def set_silent_receiver(
    linkID:int, 
    autoParity:int,
    instance:pynorm.Instance = Depends(deps.get_instance),
):
    '''
    
      要求autoParity <= numParity（创建Session时设置）
    
    '''
    session:pynorm.session.Session = get_session(instance, linkID)
    session.setAutoParity(autoParity)
    return {"sessionHandle": session._session } 


class Watermark(BaseModel):
    objectHandle:int =Field( description=''' objectHandle parameter must be a valid handle to a previously-created sender object ''')
    overrideFlush:bool = Field(default=True, description=''' ''')
    #ackNodes:list[int]= Field( description=''' the "acking node" list, when sender operation performs positive acknowledgement (ACK) collection for the specified session''')


@router.post("/watermark", response_model=Reply )
async def set_wartermark(
    linkID:int, 
    wm:Watermark,
    instance:pynorm.Instance = Depends(deps.get_instance),
):
    '''    
        bool NormSetWatermark(NormSessionHandle sessionHandle,
                              NormObjectHandle  objectHandle, 
                              bool              overrideFlush = true);
    
    '''
    session:pynorm.session.Session = get_session(instance, linkID)
    success = session.setWatermark(wm.objectHandle, wm.overrideFlush)
    if not success:
        return {"success":False,"error":"setWatermark failed!"}
    return {"success":True}

@router.delete("/watermark", response_model=Reply)
async def cancel_watermark(
    linkID:int, 
    instance:pynorm.Instance = Depends(deps.get_instance),
):
    '''
        删除Session的所有WaterMake, 返回成功或者失败
        cancels any "watermark" acknowledgement request that was previously set via the NormSetWatermark() function for the given sessionHandle
    '''
    session:pynorm.session.Session = get_session(instance, linkID)
    success = session.cancelWatermark()
    return {"success": success } 

@router.post("/ackingNode",response_model=Reply )
async def add_acking_node(
    linkID:int, 
    nodeID:int,
    instance:pynorm.Instance = Depends(deps.get_instance),
):
    '''
       添加Session/Link的ACK节点
    '''
    session:pynorm.session.Session = get_session(instance, linkID)
    success = session.addAckingNode(nodeID)
    if not success:
        return {"success":False, "error":f"addAckingNode failed: {nodeID=}"}
    
    return {"success": True}

@router.delete("/ackingNode")
async def remove_acking_Node(
    linkID:int, 
    nodeID:int,
    instance:pynorm.Instance = Depends(deps.get_instance),
):
    '''
        移除Session/Link的ACK节点
    '''
    if linkID not in instance._sessionIndex2Session:
        raise HTTPException(HTTP_400_BAD_REQUEST, detail=f"linkID `{linkID}` not exists!")
    session:pynorm.session.Session = instance._sessionIndex2Session[linkID]
    success:bool = session.removeAckingNode(nodeID) 
    if not success:
        raise HTTPException(HTTP_400_BAD_REQUEST, detail=f"nodeID `{nodeID}` is not AckNode!")
    
@router.get("/ackingNodeStatus",response_model=dict[int,str] )
async def get_status_of_acking_nodes(
    linkID:int, 
    instance:pynorm.Instance = Depends(deps.get_instance),
):
    if linkID not in instance._sessionIndex2Session:
        raise HTTPException(HTTP_400_BAD_REQUEST, detail=f"linkID {linkID} not exists!")
    session:pynorm.session.Session = instance._sessionIndex2Session[linkID]
    
    id2status = {}
    for nodeID in session.ackNodeIDs:
        status:pynorm.AckingStatus = session.getAckingStatus(nodeID )
        id2status[nodeID] = status.name        
    return id2status
    